import {
  APIRunPromptPayload,
  APIRunPromptResponse,
  ErrorResponse,
  RuntimeOptions,
  Cache,
  StreamEvents,
} from "./types";

/**
 * The client for the PromptPal JS SDK.
 */
class PromptPalClient {
  /** execute path. defined by PromptPal: https://github.com/PromptPal/PromptPal/blob/master/routes/app.go#L84 */
  static readonly executePath = "/api/v1/public/prompts/run/{pid}";
  /** endpoint of the PromptPal server. should a valid host */
  private endpoint: string;
  /** API token that generated by PromptPal project. should be pair with the endpoint */
  private token: string;

  /** cache for the PromptPal Node.js SDK */
  private cache?: Cache;

  private defaultTimeout = 10_000;

  /**
   * create a PromptPal client
   *
   * ```ts
   * const client = new PromptPal('http://127.0.0.1:7788', process.env.PROMPTPAL_TOKEN)
   * ```
   * @param endpoint PromptPal server entry point {@link endpoint}
   * @param token API token that generated by PromptPal project {@link token}
   */
  constructor(endpoint: string, token: string, options: RuntimeOptions = {}) {
    this.endpoint = endpoint;
    this.token = token;

    if (options.cache === undefined) {
      this.cache = new Map<string, string>();
    }
    if (options.cache) {
      this.cache = options.cache;
    }

    if (options.defaultTimeout) {
      this.defaultTimeout = options.defaultTimeout;
    }
  }

  protected httpPost<R, V extends object>(
    url: string,
    data: V,
    signal?: AbortSignal,
  ): Promise<R> {
    if (!this.token) {
      throw new Error("PromptPal: No token found");
    }

    const requestURL = url.startsWith("http") ? url : `${this.endpoint}${url}`;

    return fetch(requestURL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "PromptPal-JSSDK/0.1",
        Authorization: `API ${this.token}`,
      },
      body: JSON.stringify(data),
      signal,
    }).then(async (response) => {
      if (!response.ok) {
        const errMsg: ErrorResponse = await response.json();
        throw new Error(`${errMsg.code}: ${errMsg.error}`);
      }
      return response.json() as R;
    });
  }

  protected async httpPostStream<R, V extends object>(
    url: string,
    data: V,
    events: StreamEvents<APIRunPromptResponse>,
    signal?: AbortSignal,
  ): Promise<R> {
    if (!this.token) {
      throw new Error("PromptPal: No token found");
    }

    const requestURL = url.startsWith("http") ? url : `${this.endpoint}${url}`;

    const response = await fetch(requestURL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "PromptPal-JSSDK/0.1",
        Authorization: `API ${this.token}`,
      },
      body: JSON.stringify(data),
      signal,
    });

    if (!response.ok) {
      const errMsg: ErrorResponse = await response.json();
      throw new Error(`${errMsg.code}: ${errMsg.error}`);
    }

    const reader = response.body?.getReader();

    if (!reader) {
      throw new Error("body reader not found");
    }

    while (true) {
      const { done, value } = await reader.read();
      const str = new TextDecoder("utf-8").decode(value);
      if (str && str.startsWith("data:")) {
        const c = JSON.parse(str.slice(5)) as APIRunPromptResponse;
        events.onData(c);
      }
      if (done) {
        events.onEnd();
        break;
      }
    }

    return {} as any;
  }

  // .then(async response => {
  //   if (!response.ok) {
  //     const errMsg: ErrorResponse = await response.json()
  //     throw new Error(`${errMsg.code}: ${errMsg.error}`)
  //   }
  //   return response.json() as R
  // })

  /**
   * execute a prompt
   *
   * ```ts
   * const res = client.execute<PPPrompts, PPPromptEchoVariables>(
   *  PPPrompts.Echo,
   *  { text: 'hello world' }
   * )
   * ```
   *
   * @param prompt prompt hash id
   * @param variables variables
   * @param userId optional user id
   * @param config config. just signal for now
   */
  async execute<P extends string, V extends object>(
    prompt: P,
    variables: V,
    userId?: string,
    config?: {
      signal?: AbortSignal;
    },
  ): Promise<APIRunPromptResponse> {
    const cacheKey = this.getCacheKey(prompt, variables);
    if (this.cache?.has(cacheKey)) {
      return JSON.parse(this.cache.get(cacheKey)!) as APIRunPromptResponse;
    }

    const signal = config?.signal ?? AbortSignal.timeout(this.defaultTimeout);
    const result = await this.httpPost<
      APIRunPromptResponse,
      APIRunPromptPayload<V>
    >(
      PromptPalClient.executePath.replace("{pid}", prompt),
      {
        variables,
        userId,
      },
      signal,
    );
    this.cache?.set(cacheKey, JSON.stringify(result));
    return result;
  }

  /**
   * execute a prompt
   *
   * ```ts
   * const res = client.execute<PPPrompts, PPPromptEchoVariables>(
   *  PPPrompts.Echo,
   *  { text: 'hello world' }
   * )
   * ```
   *
   * @param prompt prompt hash id
   * @param variables variables
   * @param userId optional user id
   * @param config config. just signal for now
   */
  async executeStream<P extends string, V extends object>(
    prompt: P,
    variables: V,
    userId?: string,
    config?: {
      onData: (chunk: APIRunPromptResponse) => Promise<any>;
      onEnd: (chunk?: APIRunPromptResponse) => Promise<any>;
      signal?: AbortSignal;
    },
  ): Promise<APIRunPromptResponse | undefined> {
    const cacheKey = this.getCacheKey(prompt, variables);
    if (this.cache?.has(cacheKey)) {
      return JSON.parse(this.cache.get(cacheKey)!) as APIRunPromptResponse;
    }

    const signal = config?.signal ?? AbortSignal.timeout(this.defaultTimeout);

    let lastChunk: APIRunPromptResponse = {} as APIRunPromptResponse;

    function onData(chunk: APIRunPromptResponse) {
      lastChunk = chunk;
      if (config?.onData) {
        config.onData(chunk);
      }
      return Promise.resolve(chunk);
    }

    await this.httpPostStream<APIRunPromptResponse, APIRunPromptPayload<V>>(
      PromptPalClient.executePath.replace("{pid}", prompt) + "/stream",
      {
        variables,
        userId,
      },
      {
        onData,
        onEnd: config?.onEnd ?? ((_) => Promise.resolve()),
      },
      signal,
    );

    if (!lastChunk) {
      return lastChunk;
    }

    this.cache?.set(cacheKey, JSON.stringify(lastChunk));
    return lastChunk;
  }

  private getCacheKey(prompt: string, variables: Record<string, any>): string {
    let result = prompt + ":";
    const vars = Object.values(variables);
    vars.sort();
    vars.forEach((value) => {
      if (typeof value === "object") {
        // TODO, not support complex types
        return result + Math.random();
      }
      if (typeof value === "string") {
        result += value;
      }
      if (typeof value === "number") {
        result += value;
      }
    });
    return result;
  }
}

export default PromptPalClient;
