import { APIRunPromptPayload, APIRunPromptResponse, ErrorResponse, RuntimeOptions, Cache } from "./types"

/**
 * The client for the PromptPal JS SDK.
 */
class PromptPalClient {
  /** execute path. defined by PromptPal: https://github.com/PromptPal/PromptPal/blob/master/routes/app.go#L84 */
  static readonly executePath = '/api/v1/public/prompts/run/{pid}'
  /** endpoint of the PromptPal server. should a valid host */
  private endpoint: string
  /** API token that generated by PromptPal project. should be pair with the endpoint */
  private token: string

  /** cache for the PromptPal Node.js SDK */
  private cache?: Cache

  private defaultTimeout = 10_000

  /**
   * create a PromptPal client
   * 
   * ```ts
   * const client = new PromptPal('http://127.0.0.1:7788', process.env.PROMPTPAL_TOKEN)
   * ```
   * @param endpoint PromptPal server entry point {@link endpoint}
   * @param token API token that generated by PromptPal project {@link token}
   */
  constructor(endpoint: string, token: string, options: RuntimeOptions = {}) {
    this.endpoint = endpoint
    this.token = token

    if (options.cache === undefined) {
      this.cache = new Map<string, string>()
    }
    if (options.cache) {
      this.cache = options.cache
    }

    if (options.defaultTimeout) {
      this.defaultTimeout = options.defaultTimeout
    }
  }

  protected httpPost<R, V extends object>(url: string, data: V, signal?: AbortSignal): Promise<R> {
    if (!this.token) {
      throw new Error('PromptPal: No token found')
    }

    const requestURL = url.startsWith('http') ? url : `${this.endpoint}${url}`

    return fetch(requestURL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'PromptPal-JSSDK/0.1',
        Authorization: `API ${this.token}`,
      },
      body: JSON.stringify(data),
      signal,
    }).then(async response => {
      if (!response.ok) {
        const errMsg: ErrorResponse = await response.json()
        throw new Error(`${errMsg.code}: ${errMsg.error}`)
      }
      return response.json() as R
    })
  }

  /**
   * execute a prompt
   * 
   * ```ts
   * const res = client.execute<PPPrompts, PPPromptEchoVariables>(
   *  PPPrompts.Echo,
   *  { text: 'hello world' }
   * )
   * ```
   * 
   * @param prompt prompt hash id
   * @param variables variables
   * @param userId optional user id
   * @param config config. just signal for now
   */
  async execute<P extends string, V extends object>(
    prompt: P,
    variables: V,
    userId?: string,
    config?: {
      signal?: AbortSignal
    }
  ): Promise<APIRunPromptResponse> {
    const cacheKey = this.getCacheKey(prompt, variables)
    if (this.cache?.has(cacheKey)) {
      return JSON.parse(this.cache.get(cacheKey)!) as APIRunPromptResponse
    }

    const signal = config?.signal ?? AbortSignal.timeout(this.defaultTimeout)
    const result = await this.httpPost<APIRunPromptResponse, APIRunPromptPayload<V>>(
      PromptPalClient.executePath.replace('{pid}', prompt),
      {
        variables,
        userId
      },
      signal
    )
    this.cache?.set(cacheKey, JSON.stringify(result))
    return result
  }

  private getCacheKey(prompt: string, variables: Record<string, any>): string {
    let result = prompt + ':'
    const vars = Object.values(variables)
    vars.sort()
    vars.forEach(value => {
      if (typeof value === 'object') {
        // TODO, not support complex types
        return result + Math.random()
      }
      if (typeof value === 'string') {
        result += value
      }
      if (typeof value === 'number') {
        result += value
      }
    })
    return result
  }
}

export default PromptPalClient